
First release Version 1 below -------------------------------------------------------

Update: 5/12/2017 >	Powershell option now has an obfuscating option -o
			he purpose of this is to lower your bytecount. 
			It will remove un-needed whitespace, semi-coluns 
			and change all vars to a couple of letters. 
			combine with the -d option (in the same arg) to debug
			so -od or -do. For more info Rmutate -h -f6

update: 5/15/2017 >	After you convert a powershell exe to base64 you can use the w
			option to visibly see your output (helps with debugging)
			example: Rmutate -f6 .\something.ps1  -ps -ow
			that would show the windows mode for an executable Rmutate Script
			that is also obfuscated.

			Issue resolved where o'' and b'' would not work if 
			-jcp was not used on unix and the 2nd var on up started with a /
			and the bit count for that register was under 64 bits.

			Originally, the -b'' and -o'' only worked in powershell, now it works in
			both cmd and powershell.



Version 2 released below ------------------------------------------------------------

update: 5/27/2017 >	I changed the ascii encoding from UTF-8 to iso-8859-1 so more
			hex values would be converted. I removed the single quotes around the
			metasploit architecture (fix). The support_esc.rb has been updated to 
			support jcp. Also, if fix the ascii conversion if a pointer was used.
			The final additionwas that  the jcp code will be placed at the bottom
			of the conversion. To see if jcp code was used "objdump -d <file>" and
			you should see a block of 16 bytes. If not, obj jcp code was not used.

			I used exception handling to take care of the clipboard content being
			too long. If you get the result
			OSError: [Errno 7] Argument list too long
			you will be given the option to write the contents to a file.
			This does not include the esc tool, for that just use a re-direction
			to a file.

			I added the regex \s*\.\.\. to esc to account for null bytes. As a 
			shellcoder you will want null bytes if you have multiple JCPs.
			If used correctly, no encoder will be needed.

			I added shorthand so for example, -ath could be written as ah
			remove the "-" and the "t" when using a conversion.
			Also -hti and ith (aka hi and ih) converts hex to int and int to hex

			I added a new shellcode execution method (write and execute from hex)
			Use -fx to learn more. This writes to the filesystem unlike -f6 which
			writes to memory.

			I made the -fx and the -f6 jcp db block formated. That way making
			changes won't crash your gedit if your string is too long. You can also
			use the n in -sb and -nb to get block formats as well Rmutate -h -fx
			to learn more.

			new universal option: -cb (clipboard) and -pp (pipe)
			example: echo hello | Rmutate ha -pp
			would give you the hex for hello

			new conversion option: -ch and -c6
			If you have a script that you want to use that is in hex (convert hex -ch)
			just use the -ch so: Rmutate -s <hex string> -linux -ex -ch
			You can use this with what is above, say you have a whole command written
			in hex that is in a file: cat hex_file.txt | Rmutate -s -pp -linux -ex -ch


update: 6/03/2017 >	I added a hth function. This is good when you want to convert
			one style of hex to a different style of hex. 
			So from "\x41\x42" to 0x4142 as an example.
			This combines -hta and -ath 
			-hta (because it must organize different hex input) and then -ath to 
			give different hex ouput
			Rmutate -hh -cb -nb (where -cb is a shellcode block in clipboard)
			would output a nasm block code syntax

			Rasm2 is now included with the -Rasm2 option.
			Rasm2 works like gdb except with the help of Rmutate.
			You can pipe C files with shellcode into Rmutate and get the assembly
			equivilent as output, you can even output as a unix/win file and exec.

			Added -mul and -div to the -bit (-bit used to be a part of hta), also I added shorthand, 
			so you can type m for mul, a for add, etc (not and and are the only ones left unchanged)

update: 8/13/2017 >	bit and hta are now seperated. You can use bit for your bitwise functions
			sense it is probably easier to remember for that than -hta. 
			I fixed the hex to ascii conversion to translate one byte at a time. That way if you
			get something like \x09, the byte will just be ignored instead of giving no output.
			Piping into Rmutate with a newline will now function properly in hta.
			The clipboard will now input a "\n" or a "`n" (os dependent) where you have a newline,
			instead of removing all new lines. Just echo -e + clipboard to view it naturally.


Current Rmutate v(Update Cluster).(update).(hotfix)

----------------------------------- Current Rmutate v2.1.2 ------------------------------------


