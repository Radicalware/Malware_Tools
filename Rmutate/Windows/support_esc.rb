#!/usr/bin/env ruby 

# Author : Scourge
# email  : Scourge@protonmail.com
# Licence: GPLv3

jcp_line = false
relaps = false
shellcode = []

argCount = ARGV.length

def uncrypt(shellcode)
	code = shellcode.join("")
	code = ('2f2f7c7c2020'+code)
	code.gsub! '0a', '0a2f2f7c7c2020'
	code = [code].pack('H*').encode("UTF-8","Windows-1252")
	code = code.split('\n')
	puts code
end


begin
	stdin_test = STDIN.first
rescue
	puts ('Be sure to use esc (Extract ShellCode), don\'t use this directly');exit()
end

if  ARGV[0] == '/d'
	puts "\n"
	puts "//|"+"|"*97
	while 
		content = STDIN.first
		lines = content.split("\n")
		for line in lines
			if /<*>:/.match(line) and jcp_line == false and /<command[0-9]>:/.match(line) == nil
				puts '//|'+'-'*97+"\n//|"+(line.split(/\s/)[1].delete '<:>').center(89)+"\n"+'//|'+'-'*97

			elsif /\s*\.\.\./.match(line)
				bytes = '"'+'\\x00'+'"'
				ascii = ''
				puts (("\s"*3+bytes.ljust(35,))+('//| ')+(ascii).center(10,))+' |'

			elsif /\s[0-9a-f]{2}/.match(line) and jcp_line == false
				command = line.split(/\t/)[2]
				bytes = '"'+'\\x'+line.split(/\t/)[1].to_s.split("\s").join("\\x")+'"'
				#            ^                   ^               ^         

				if /0x/.match(command)
					begin
						ascii_forward_array = [] # \n(or)\]
						split_location = command.scan(/0x/).count
						ascii_scan = command.split('0x')[split_location].scan /[0-9a-f]{2}/
						ascii_scan.each do |item|
							numbered = item.to_i(16)
							if numbered > 31 and numbered < 127
								item = [item].pack('H*').encode("UTF-8","Windows-1252")
								ascii_forward_array.insert(0,item)
							else
								ascii_forward_array.insert(0,' ')
							end
						end

						ascii = ascii_forward_array.join('')
					rescue
						ascii = ''
					end
				else
					ascii = ''
				end # end if

				begin 
					puts (("\s"*3+bytes.ljust(35,))+('//| ')+(ascii).center(10,)+(' |  '+command))
					# ljust pushes whitespace after the end of the content
				rescue
					puts (("\s"*3+bytes.ljust(35,))+('//| ')+(ascii).center(10,))+' |'
				end 
			elsif jcp_line == true and /\s[0-9a-f]{2}/.match(line) == nil
				uncrypt(shellcode)
			elsif /[[0-9]{2}[\s]]{16}/.match(line) and jcp_line == false
				jcp_line = true
				puts '//|'+'-'*97+"\n//|"+(line.split(/\s/)[1].delete '<:>').center(89)+"\n"+'//|'+'-'*97
			elsif jcp_line == true and /[0-9a-f]{2}/.match(line)
				command = line.split(/\t/)[1]
				command = command.sub(/     /,'(){}()[]()')
				command = command.split(/\(\)\{\}\(\)\[\]\(\)/)[0]
				bytes = '"'+'\\x'+command.to_s.split("\s").join("\\x")+'"'
				puts ("\s"*3+bytes.center(89))
				bytes = command.scan(/[0-9a-f]{2}/)
				bytes.each do |byte|
					shellcode.insert(-1,byte)
				end

			end		
		end

	end
	puts "//|"+"|"*97
else
	shellcode = ''
	while
		content = STDIN.first
		lines = content.split("\n")
		for line in lines
			if /\s*\.\.\./.match(line)
				bytes = '\\x00'
				puts bytes
			elsif /\s[0-9a-f]{2}/.match(line)
				bytes = '\\x'+line.split(/\t/)[1].to_s.split(' ').join("\\x")				
				#            ^                   ^               ^         
				shellcode += bytes
				if ARGV.length == 0
					puts bytes
				end
			else
				# no "pass" in ruby sense you can have empty statments
			end
		end
	end
end


if jcp_line == true
	puts "//||"
	code = uncrypt(shellcode)
end

if ARGV[0] == '/a'
	shellcode.gsub! '\\x',''
	system('echo '+shellcode+ ' | Rmutate.exe -h -a pp')
end